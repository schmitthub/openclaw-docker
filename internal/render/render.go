package render

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/schmitthub/openclaw-docker/internal/versions"
)

type Options struct {
	Meta                 versions.ReleaseMeta
	OutputDir            string
	Cleanup              bool
	DockerAptPackages    string
	OpenClawConfigDir    string
	OpenClawWorkspaceDir string
	OpenClawGatewayPort  string
	OpenClawBridgePort   string
	OpenClawGatewayBind  string
	OpenClawImage        string
	OpenClawGatewayToken string
	OpenClawExtraMounts  string
	OpenClawHomeVolume   string
	ConfirmWrite         func(path string) error
}

func Generate(opts Options) error {
	if opts.OutputDir == "" {
		return fmt.Errorf("output directory is required")
	}

	if err := os.MkdirAll(opts.OutputDir, 0o755); err != nil {
		return fmt.Errorf("create output directory: %w", err)
	}

	if opts.Cleanup {
		fmt.Fprintf(
			os.Stderr,
			"Defensive warning: cleanup requested for %s\nPrompt: this path would be cleared in cleanup mode, but delete operations are disabled; continuing in additive overwrite-only mode.\n",
			opts.OutputDir,
		)
	}

	dockerfilePath := filepath.Join(opts.OutputDir, "Dockerfile")
	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(dockerfilePath); err != nil {
			return err
		}
	}
	content := dockerfileFor(opts)
	if err := os.WriteFile(dockerfilePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write Dockerfile %q: %w", dockerfilePath, err)
	}

	if err := writeComposeArtifacts(opts); err != nil {
		return err
	}

	if err := writeSetupScript(opts); err != nil {
		return err
	}

	return nil
}

func writeComposeArtifacts(opts Options) error {
	composePath := filepath.Join(opts.OutputDir, "compose.yaml")
	envPath := filepath.Join(opts.OutputDir, ".env.openclaw")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(composePath); err != nil {
			return err
		}
	}

	composeContent := composeFileContent()
	if err := os.WriteFile(composePath, []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("write compose file %q: %w", composePath, err)
	}

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(envPath); err != nil {
			return err
		}
	}

	envContent := openClawEnvFileContent(opts)
	if err := os.WriteFile(envPath, []byte(envContent), 0o644); err != nil {
		return fmt.Errorf("write env file %q: %w", envPath, err)
	}

	return nil
}

func writeSetupScript(opts Options) error {
	setupPath := filepath.Join(opts.OutputDir, "setup.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(setupPath); err != nil {
			return err
		}
	}

	content := setupScriptContent(opts)
	if err := os.WriteFile(setupPath, []byte(content), 0o755); err != nil {
		return fmt.Errorf("write setup script %q: %w", setupPath, err)
	}

	return nil
}

func composeFileContent() string {
	lines := []string{
		"# Generated by openclaw-docker. Do not edit directly.",
		"services:",
		"  squid:",
		"    image: ubuntu/squid:latest",
		"    restart: unless-stopped",
		"    networks:",
		"      - openclaw-internal",
		"      - openclaw-egress",
		"",
		"  openclaw-gateway:",
		"    build:",
		"      context: .",
		"      dockerfile: Dockerfile",
		"    env_file:",
		"      - .env.openclaw",
		"    environment:",
		"      OPENCLAW_CONFIG_DIR: ${OPENCLAW_CONFIG_DIR}",
		"      OPENCLAW_WORKSPACE_DIR: ${OPENCLAW_WORKSPACE_DIR}",
		"      OPENCLAW_GATEWAY_PORT: ${OPENCLAW_GATEWAY_PORT}",
		"      OPENCLAW_BRIDGE_PORT: ${OPENCLAW_BRIDGE_PORT}",
		"      OPENCLAW_GATEWAY_BIND: ${OPENCLAW_GATEWAY_BIND}",
		"      OPENCLAW_GATEWAY_TOKEN: ${OPENCLAW_GATEWAY_TOKEN}",
		"      HTTP_PROXY: ${OPENCLAW_HTTP_PROXY}",
		"      HTTPS_PROXY: ${OPENCLAW_HTTPS_PROXY}",
		"      NO_PROXY: ${OPENCLAW_NO_PROXY}",
		"    ports:",
		"      - \"${OPENCLAW_GATEWAY_PORT}:${OPENCLAW_GATEWAY_PORT}\"",
		"      - \"${OPENCLAW_BRIDGE_PORT}:${OPENCLAW_BRIDGE_PORT}\"",
		"    volumes:",
		"      - ${OPENCLAW_CONFIG_DIR}:${OPENCLAW_CONFIG_DIR}",
		"      - ${OPENCLAW_WORKSPACE_DIR}:${OPENCLAW_WORKSPACE_DIR}",
		"      - /var/run/docker.sock:/var/run/docker.sock",
		"    depends_on:",
		"      - squid",
		"    networks:",
		"      - openclaw-internal",
		"",
		"  openclaw-cli:",
		"    build:",
		"      context: .",
		"      dockerfile: Dockerfile",
		"    env_file:",
		"      - .env.openclaw",
		"    environment:",
		"      OPENCLAW_CONFIG_DIR: ${OPENCLAW_CONFIG_DIR}",
		"      OPENCLAW_WORKSPACE_DIR: ${OPENCLAW_WORKSPACE_DIR}",
		"      OPENCLAW_GATEWAY_PORT: ${OPENCLAW_GATEWAY_PORT}",
		"      OPENCLAW_BRIDGE_PORT: ${OPENCLAW_BRIDGE_PORT}",
		"      OPENCLAW_GATEWAY_BIND: ${OPENCLAW_GATEWAY_BIND}",
		"      OPENCLAW_GATEWAY_TOKEN: ${OPENCLAW_GATEWAY_TOKEN}",
		"      HTTP_PROXY: ${OPENCLAW_HTTP_PROXY}",
		"      HTTPS_PROXY: ${OPENCLAW_HTTPS_PROXY}",
		"      NO_PROXY: ${OPENCLAW_NO_PROXY}",
		"    volumes:",
		"      - ${OPENCLAW_CONFIG_DIR}:${OPENCLAW_CONFIG_DIR}",
		"      - ${OPENCLAW_WORKSPACE_DIR}:${OPENCLAW_WORKSPACE_DIR}",
		"      - /var/run/docker.sock:/var/run/docker.sock",
		"    depends_on:",
		"      - squid",
		"    networks:",
		"      - openclaw-internal",
		"    profiles: [\"cli\"]",
		"",
		"networks:",
		"  openclaw-internal:",
		"    internal: true",
		"  openclaw-egress:",
	}

	return strings.Join(lines, "\n") + "\n"
}

func openClawEnvFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Adjust values as needed.
OPENCLAW_CONFIG_DIR=%s
OPENCLAW_WORKSPACE_DIR=%s
OPENCLAW_GATEWAY_PORT=%s
OPENCLAW_BRIDGE_PORT=%s
OPENCLAW_GATEWAY_BIND=%s
OPENCLAW_GATEWAY_TOKEN=%s
OPENCLAW_DOCKER_APT_PACKAGES=%s
OPENCLAW_EXTRA_MOUNTS=%s
OPENCLAW_HOME_VOLUME=%s
OPENCLAW_HTTP_PROXY=http://squid:3128
OPENCLAW_HTTPS_PROXY=http://squid:3128
OPENCLAW_NO_PROXY=localhost,127.0.0.1,squid,openclaw-gateway,openclaw-cli
`, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind, opts.OpenClawGatewayToken, opts.DockerAptPackages, opts.OpenClawExtraMounts, opts.OpenClawHomeVolume)
}

func dockerfileFor(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`#
# NOTE: THIS DOCKERFILE IS GENERATED VIA "openclaw-docker"
#
# PLEASE DO NOT EDIT IT DIRECTLY.
#

FROM node:22-bookworm

ARG OPENCLAW_DOCKER_APT_PACKAGES="%s"
RUN if [ -n "$OPENCLAW_DOCKER_APT_PACKAGES" ]; then \
      apt-get update && \
      DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
        $OPENCLAW_DOCKER_APT_PACKAGES && \
      apt-get clean && \
      rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*; \
    fi

RUN corepack enable

WORKDIR /app
RUN chown node:node /app

ENV OPENCLAW_VERSION=%s
ENV OPENCLAW_CONFIG_DIR=%s
ENV OPENCLAW_WORKSPACE_DIR=%s
ENV OPENCLAW_GATEWAY_PORT=%s
ENV OPENCLAW_BRIDGE_PORT=%s
ENV OPENCLAW_GATEWAY_BIND=%s

# Create config and workspace directories
RUN mkdir -p "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}" && \
    chown -R node:node "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}"

USER node

# Install OpenClaw
RUN OPENCLAW_NO_PROMPT=1 OPENCLAW_NO_ONBOARD=1 \
  curl -fsSL "https://openclaw.ai/install.sh" | \
  bash -s -- --version "${OPENCLAW_VERSION}"

ENV NODE_ENV=production

# Start gateway server with default config.
# For container platforms requiring external health checks:
#   1. Set OPENCLAW_GATEWAY_TOKEN or OPENCLAW_GATEWAY_PASSWORD env var
#   2. Override CMD to include: --bind lan
CMD ["node", "openclaw.mjs", "gateway", "--allow-unconfigured"]
`, opts.DockerAptPackages, opts.Meta.FullVersion, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind)
}

func setupScriptContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	return fmt.Sprintf(`#!/usr/bin/env bash
# Generated by openclaw-docker. Adjust as needed.
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$ROOT_DIR/compose.yaml"
ENV_FILE="$ROOT_DIR/.env.openclaw"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing dependency: $1" >&2
    exit 1
  fi
}

# Read gateway token from existing openclaw config if available.
read_config_gateway_token() {
  local config_path="%s/openclaw.json"
  if [[ ! -f "$config_path" ]]; then
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$config_path" <<'PY'
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    token = cfg.get("gateway", {}).get("auth", {}).get("token", "")
    if token.strip():
        print(token.strip())
except Exception:
    pass
PY
    return 0
  fi
  if command -v node >/dev/null 2>&1; then
    node - "$config_path" <<'NODE'
const fs = require("node:fs");
try {
  const cfg = JSON.parse(fs.readFileSync(process.argv[2], "utf8"));
  const token = cfg?.gateway?.auth?.token;
  if (typeof token === "string" && token.trim()) process.stdout.write(token.trim());
} catch {}
NODE
  fi
}

# Idempotent env file upsert (Bash 3.2 compatible).
upsert_env() {
  local file="$1"
  shift
  local -a keys=("$@")
  local tmp
  tmp="$(mktemp)"
  local seen=" "

  if [[ -f "$file" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      local key="${line%%%%=*}"
      local replaced=false
      for k in "${keys[@]}"; do
        if [[ "$key" == "$k" ]]; then
          printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
          seen="$seen$k "
          replaced=true
          break
        fi
      done
      if [[ "$replaced" == false ]]; then
        printf '%%s\n' "$line" >>"$tmp"
      fi
    done <"$file"
  fi

  for k in "${keys[@]}"; do
    if [[ "$seen" != *" $k "* ]]; then
      printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
    fi
  done

  mv "$tmp" "$file"
}

require_cmd docker
if ! docker compose version >/dev/null 2>&1; then
  fail "Docker Compose not available (try: docker compose version)"
fi

# Config and workspace directories
OPENCLAW_CONFIG_DIR="${OPENCLAW_CONFIG_DIR:-%s}"
OPENCLAW_WORKSPACE_DIR="${OPENCLAW_WORKSPACE_DIR:-%s}"

mkdir -p "$OPENCLAW_CONFIG_DIR"
mkdir -p "$OPENCLAW_WORKSPACE_DIR"
mkdir -p "$OPENCLAW_CONFIG_DIR/identity"

export OPENCLAW_CONFIG_DIR
export OPENCLAW_WORKSPACE_DIR
export OPENCLAW_GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-%s}"
export OPENCLAW_BRIDGE_PORT="${OPENCLAW_BRIDGE_PORT:-18790}"
export OPENCLAW_GATEWAY_BIND="${OPENCLAW_GATEWAY_BIND:-lan}"

# Gateway token: reuse from config, env, or generate new.
if [[ -z "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
  EXISTING_TOKEN="$(read_config_gateway_token || true)"
  if [[ -n "$EXISTING_TOKEN" ]]; then
    OPENCLAW_GATEWAY_TOKEN="$EXISTING_TOKEN"
    echo "Reusing gateway token from $OPENCLAW_CONFIG_DIR/openclaw.json"
  elif command -v openssl >/dev/null 2>&1; then
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
  else
    OPENCLAW_GATEWAY_TOKEN="$(python3 -c 'import secrets; print(secrets.token_hex(32))')"
  fi
fi
export OPENCLAW_GATEWAY_TOKEN

# Update .env file with current values.
upsert_env "$ENV_FILE" \
  OPENCLAW_CONFIG_DIR \
  OPENCLAW_WORKSPACE_DIR \
  OPENCLAW_GATEWAY_PORT \
  OPENCLAW_BRIDGE_PORT \
  OPENCLAW_GATEWAY_BIND \
  OPENCLAW_GATEWAY_TOKEN

echo "==> Building image"
docker compose -f "$COMPOSE_FILE" build

echo ""
echo "==> Starting gateway"
docker compose -f "$COMPOSE_FILE" up -d openclaw-gateway

echo ""
echo "Gateway running."
echo "Config:    $OPENCLAW_CONFIG_DIR"
echo "Workspace: $OPENCLAW_WORKSPACE_DIR"
echo "Token:     $OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Commands:"
echo "  docker compose -f $COMPOSE_FILE logs -f openclaw-gateway"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli onboard --no-install-daemon"
echo ""
echo "Provider setup:"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels login          # WhatsApp (QR)"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels add --channel telegram --token <token>"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels add --channel discord --token <token>"
`, configDir, configDir, workspaceDir, gatewayPort)
}
