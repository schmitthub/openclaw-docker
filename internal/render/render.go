package render

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/schmitthub/openclaw-docker/internal/versions"
)

type Options struct {
	Meta                 versions.ReleaseMeta
	OutputDir            string
	Cleanup              bool
	DockerAptPackages    string
	OpenClawConfigDir    string
	OpenClawWorkspaceDir string
	OpenClawGatewayPort  string
	OpenClawBridgePort   string
	OpenClawGatewayBind  string
	OpenClawImage        string
	OpenClawGatewayToken string
	AllowedDomains       string
	ExternalOrigin       string
	ConfirmWrite         func(path string) error
}

func Generate(opts Options) error {
	if opts.OutputDir == "" {
		return fmt.Errorf("output directory is required")
	}

	// Create output root and compose service subdirectories.
	for _, sub := range []string{
		"",
		"compose/openclaw",
		"compose/envoy",
		"data/config",
		"data/workspace",
	} {
		dir := filepath.Join(opts.OutputDir, sub)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("create directory %q: %w", dir, err)
		}
	}

	if opts.Cleanup {
		fmt.Fprintf(
			os.Stderr,
			"Defensive warning: cleanup requested for %s\nPrompt: this path would be cleared in cleanup mode, but delete operations are disabled; continuing in additive overwrite-only mode.\n",
			opts.OutputDir,
		)
	}

	dockerfilePath := filepath.Join(opts.OutputDir, "compose", "openclaw", "Dockerfile")
	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(dockerfilePath); err != nil {
			return err
		}
	}
	content := dockerfileFor(opts)
	if err := os.WriteFile(dockerfilePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write Dockerfile %q: %w", dockerfilePath, err)
	}

	if err := writeEntrypoint(opts); err != nil {
		return err
	}

	if err := writeComposeArtifacts(opts); err != nil {
		return err
	}

	if err := writeSetupScript(opts); err != nil {
		return err
	}

	if err := generateTLSCert(opts); err != nil {
		return err
	}

	if err := writeEnvoyConfig(opts); err != nil {
		return err
	}

	return nil
}

func writeComposeArtifacts(opts Options) error {
	composePath := filepath.Join(opts.OutputDir, "compose.yaml")
	envPath := filepath.Join(opts.OutputDir, ".env.openclaw")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(composePath); err != nil {
			return err
		}
	}

	composeContent := composeFileContent(opts)
	if err := os.WriteFile(composePath, []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("write compose file %q: %w", composePath, err)
	}

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(envPath); err != nil {
			return err
		}
	}

	envContent := openClawEnvFileContent(opts)
	if err := os.WriteFile(envPath, []byte(envContent), 0o644); err != nil {
		return fmt.Errorf("write env file %q: %w", envPath, err)
	}

	return nil
}

func writeSetupScript(opts Options) error {
	setupPath := filepath.Join(opts.OutputDir, "setup.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(setupPath); err != nil {
			return err
		}
	}

	content := setupScriptContent(opts)
	if err := os.WriteFile(setupPath, []byte(content), 0o755); err != nil {
		return fmt.Errorf("write setup script %q: %w", setupPath, err)
	}

	return nil
}

func composeFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	lines := []string{
		"# Generated by openclaw-docker. Do not edit directly.",
		"services:",
		"  envoy:",
		"    image: envoyproxy/envoy:v1.33-latest",
		"    restart: unless-stopped",
		"    ports:",
		"      - \"443:443\"",
		"    volumes:",
		"      - ./compose/envoy/envoy.yaml:/etc/envoy/envoy.yaml:ro",
		"      - ./compose/envoy/server-cert.pem:/etc/envoy/certs/server-cert.pem:ro",
		"      - ./compose/envoy/server-key.pem:/etc/envoy/certs/server-key.pem:ro",
		"    networks:",
		"      - openclaw-internal",
		"      - openclaw-egress",
		"",
		"  openclaw-gateway:",
		"    build:",
		"      context: ./compose/openclaw",
		"      dockerfile: Dockerfile",
		"    cap_add:",
		"      - NET_ADMIN",
		"    environment:",
		"      HOME: /home/node",
		"      TERM: xterm-256color",
		"    env_file:",
		"      - .env.openclaw",
		"    volumes:",
		fmt.Sprintf("      - ./data/config:%s", configDir),
		fmt.Sprintf("      - ./data/workspace:%s", workspaceDir),
		fmt.Sprintf("    command: [\"openclaw\", \"gateway\", \"--bind\", \"lan\", \"--port\", \"%s\"]", gatewayPort),
		"    init: true",
		"    restart: unless-stopped",
		"    depends_on:",
		"      - envoy",
		"    networks:",
		"      - openclaw-internal",
		"",
		"  openclaw-cli:",
		"    build:",
		"      context: ./compose/openclaw",
		"      dockerfile: Dockerfile",
		"    entrypoint: [\"openclaw\"]",
		"    environment:",
		"      HOME: /home/node",
		"      TERM: xterm-256color",
		"      BROWSER: echo",
		"    env_file:",
		"      - .env.openclaw",
		"    volumes:",
		fmt.Sprintf("      - ./data/config:%s", configDir),
		fmt.Sprintf("      - ./data/workspace:%s", workspaceDir),
		"    stdin_open: true",
		"    tty: true",
		"    init: true",
		"    networks:",
		"      - openclaw-internal",
		"",
		"networks:",
		"  openclaw-internal:",
		"    internal: true",
		"  openclaw-egress:",
	}

	return strings.Join(lines, "\n") + "\n"
}

func openClawEnvFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Adjust values as needed.
OPENCLAW_CONFIG_DIR=%s
OPENCLAW_WORKSPACE_DIR=%s
OPENCLAW_GATEWAY_PORT=%s
OPENCLAW_BRIDGE_PORT=%s
OPENCLAW_GATEWAY_BIND=%s
OPENCLAW_GATEWAY_TOKEN=%s
OPENCLAW_DOCKER_APT_PACKAGES=%s
HTTP_PROXY=http://envoy:10000
HTTPS_PROXY=http://envoy:10000
NO_PROXY=localhost,127.0.0.1,envoy,openclaw-gateway
`, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind, opts.OpenClawGatewayToken, opts.DockerAptPackages)
}

func dockerfileFor(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`#
# NOTE: THIS DOCKERFILE IS GENERATED VIA "openclaw-docker"
#
# PLEASE DO NOT EDIT IT DIRECTLY.
#

FROM node:22-bookworm

ARG OPENCLAW_DOCKER_APT_PACKAGES="%s"
RUN apt-get update && \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
      iptables gosu \
      $OPENCLAW_DOCKER_APT_PACKAGES && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*

RUN corepack enable && \
    corepack prepare pnpm@latest --activate && \
    BUN_INSTALL=/usr/local curl -fsSL https://bun.sh/install | bash

WORKDIR /app
RUN chown node:node /app

ENV OPENCLAW_VERSION=%s
ENV OPENCLAW_CONFIG_DIR=%s
ENV OPENCLAW_WORKSPACE_DIR=%s
ENV OPENCLAW_GATEWAY_PORT=%s
ENV OPENCLAW_BRIDGE_PORT=%s
ENV OPENCLAW_GATEWAY_BIND=%s

# Create config and workspace directories
RUN mkdir -p "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}" && \
    chown -R node:node "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}"

# Install OpenClaw via npm (global, as root → /usr/local)
RUN SHARP_IGNORE_GLOBAL_LIBVIPS=1 \
    npm install -g --no-fund --no-audit "openclaw@${OPENCLAW_VERSION}"

# CLI symlink for consistent access across users
RUN ln -sf "$(npm root -g)/openclaw/dist/entry.js" /usr/local/bin/openclaw && \
    chmod 755 "$(npm root -g)/openclaw/dist/entry.js"

# Optional: bake Playwright + Chromium into the image for browser automation.
# Build with: docker build --build-arg OPENCLAW_INSTALL_BROWSER=1 ...
# Adds ~300MB but eliminates the 60-90s Playwright install on every container start.
ARG OPENCLAW_INSTALL_BROWSER=""
RUN if [ -n "$OPENCLAW_INSTALL_BROWSER" ]; then \
      apt-get update && \
      DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends xvfb && \
      mkdir -p /home/node/.cache/ms-playwright && \
      PLAYWRIGHT_BROWSERS_PATH=/home/node/.cache/ms-playwright \
      node "$(npm root -g)/openclaw/node_modules/playwright-core/cli.js" install --with-deps chromium && \
      chown -R node:node /home/node/.cache/ms-playwright && \
      apt-get clean && \
      rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*; \
    fi

COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod 755 /usr/local/bin/entrypoint.sh

ENV NODE_ENV=production

ENTRYPOINT ["entrypoint.sh"]
CMD ["openclaw", "gateway", "--allow-unconfigured"]
`, opts.DockerAptPackages, opts.Meta.FullVersion, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind)
}

func setupScriptContent(opts Options) string {
	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	return fmt.Sprintf(`#!/usr/bin/env bash
# Generated by openclaw-docker. Adjust as needed.
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$ROOT_DIR/compose.yaml"
ENV_FILE="$ROOT_DIR/.env.openclaw"

# Host-side data directories (bind-mounted into the container).
HOST_CONFIG_DIR="$ROOT_DIR/data/config"
HOST_WORKSPACE_DIR="$ROOT_DIR/data/workspace"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing dependency: $1" >&2
    exit 1
  fi
}

# Read gateway token from existing openclaw config if available.
read_config_gateway_token() {
  local config_path="$HOST_CONFIG_DIR/openclaw.json"
  if [[ ! -f "$config_path" ]]; then
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$config_path" <<'PY'
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    token = cfg.get("gateway", {}).get("auth", {}).get("token", "")
    if token.strip():
        print(token.strip())
except Exception:
    pass
PY
    return 0
  fi
  if command -v node >/dev/null 2>&1; then
    node - "$config_path" <<'NODE'
const fs = require("node:fs");
try {
  const cfg = JSON.parse(fs.readFileSync(process.argv[2], "utf8"));
  const token = cfg?.gateway?.auth?.token;
  if (typeof token === "string" && token.trim()) process.stdout.write(token.trim());
} catch {}
NODE
  fi
}

# Idempotent env file upsert (Bash 3.2 compatible).
upsert_env() {
  local file="$1"
  shift
  local -a keys=("$@")
  local tmp
  tmp="$(mktemp)"
  local seen=" "

  if [[ -f "$file" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      local key="${line%%%%=*}"
      local replaced=false
      for k in "${keys[@]}"; do
        if [[ "$key" == "$k" ]]; then
          printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
          seen="$seen$k "
          replaced=true
          break
        fi
      done
      if [[ "$replaced" == false ]]; then
        printf '%%s\n' "$line" >>"$tmp"
      fi
    done <"$file"
  fi

  for k in "${keys[@]}"; do
    if [[ "$seen" != *" $k "* ]]; then
      printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
    fi
  done

  mv "$tmp" "$file"
}

require_cmd docker
if ! docker compose version >/dev/null 2>&1; then
  fail "Docker Compose not available (try: docker compose version)"
fi

# Create host-side data directories.
mkdir -p "$HOST_CONFIG_DIR"
mkdir -p "$HOST_WORKSPACE_DIR"
mkdir -p "$HOST_CONFIG_DIR/identity"

export OPENCLAW_GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-%s}"
export OPENCLAW_BRIDGE_PORT="${OPENCLAW_BRIDGE_PORT:-18790}"
export OPENCLAW_GATEWAY_BIND="${OPENCLAW_GATEWAY_BIND:-lan}"

# Gateway token: reuse from config, env, or generate new.
if [[ -z "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
  EXISTING_TOKEN="$(read_config_gateway_token || true)"
  if [[ -n "$EXISTING_TOKEN" ]]; then
    OPENCLAW_GATEWAY_TOKEN="$EXISTING_TOKEN"
    echo "Reusing gateway token from $HOST_CONFIG_DIR/openclaw.json"
  elif command -v openssl >/dev/null 2>&1; then
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
  else
    OPENCLAW_GATEWAY_TOKEN="$(python3 -c 'import secrets; print(secrets.token_hex(32))')"
  fi
fi
export OPENCLAW_GATEWAY_TOKEN

# Update .env file with runtime values (token, port, bind).
upsert_env "$ENV_FILE" \
  OPENCLAW_GATEWAY_PORT \
  OPENCLAW_BRIDGE_PORT \
  OPENCLAW_GATEWAY_BIND \
  OPENCLAW_GATEWAY_TOKEN

ensure_control_ui_allowed_origins() {
  local allowed_origin_json='["https://localhost"]'

  local current
  current="$(
    docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
      config get gateway.controlUi.allowedOrigins 2>/dev/null || true
  )"
  current="${current//$'\r'/}"

  if [[ -n "$current" && "$current" != "null" && "$current" != "[]" ]]; then
    echo "Control UI allowlist already configured; leaving gateway.controlUi.allowedOrigins unchanged."
    return 0
  fi

  docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
    config set gateway.controlUi.allowedOrigins \
    "$allowed_origin_json" --strict-json >/dev/null
  echo "Set gateway.controlUi.allowedOrigins to $allowed_origin_json"
}

echo "==> Building images"
docker compose -f "$COMPOSE_FILE" build

echo ""
echo "==> Onboarding (interactive)"
echo "When prompted:"
echo "  - Gateway bind: lan"
echo "  - Gateway auth: token"
echo "  - Gateway token: $OPENCLAW_GATEWAY_TOKEN"
echo "  - Tailscale exposure: Off"
echo "  - Install Gateway daemon: No"
echo ""
docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli onboard --no-install-daemon

echo ""
echo "==> Setting gateway auth token"
docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
  config set gateway.auth.mode token >/dev/null
docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
  config set gateway.auth.token "$OPENCLAW_GATEWAY_TOKEN" >/dev/null
echo "Gateway token set (matches .env.openclaw)."

echo ""
echo "==> Disable device auth (not compatible with reverse proxy)"
# Control UI always uses device pairing even behind a trusted proxy.
# See: https://github.com/openclaw/openclaw/issues/25293
#      https://github.com/openclaw/openclaw/issues/4941
docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
  config set gateway.controlUi.dangerouslyDisableDeviceAuth true >/dev/null
echo "Device auth disabled (token auth + TLS via Envoy is the security boundary)."

echo ""
echo "==> Trusted proxies (Docker network CIDRs)"
docker compose -f "$COMPOSE_FILE" run --rm openclaw-cli \
  config set gateway.trustedProxies \
  '["172.16.0.0/12", "10.0.0.0/8", "192.168.0.0/16"]' --strict-json >/dev/null
echo "Set gateway.trustedProxies for Docker network forwarding."

echo ""
echo "==> Control UI origin allowlist"
ensure_control_ui_allowed_origins

echo ""
echo "==> Provider setup (optional)"
echo "WhatsApp (QR):"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels login"
echo "Telegram (bot token):"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels add --channel telegram --token <token>"
echo "Discord (bot token):"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli channels add --channel discord --token <token>"
echo "Docs: https://docs.openclaw.ai/channels"

echo ""
echo "==> Starting services"
docker compose -f "$COMPOSE_FILE" up -d

echo ""
echo "Gateway running."
echo ""
echo "  Open: https://localhost/?token=$OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Config:    $HOST_CONFIG_DIR"
echo "Workspace: $HOST_WORKSPACE_DIR"
echo "Token:     $OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Commands:"
echo "  docker compose -f $COMPOSE_FILE logs -f openclaw-gateway"
echo "  docker compose -f $COMPOSE_FILE run --rm openclaw-cli config get gateway"
echo ""
echo "Envoy config:   $ROOT_DIR/compose/envoy/envoy.yaml"
echo "Gateway config: $HOST_CONFIG_DIR/openclaw.json"
`, gatewayPort)
}

func envoyConfigContent(opts Options) string {
	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	// Build the domain list for the egress whitelist.
	// These domains are always included regardless of --allowed-domains.
	alwaysAllowed := []string{
		"clawhub.com",
		"registry.npmjs.org",
	}

	// Deduplicate: start with always-allowed, then add user-specified domains.
	seen := make(map[string]bool)
	var domains []string
	for _, d := range alwaysAllowed {
		seen[d] = true
		domains = append(domains, d)
	}
	if opts.AllowedDomains != "" {
		for _, d := range strings.Split(opts.AllowedDomains, ",") {
			d = strings.TrimSpace(d)
			if d != "" && !seen[d] {
				seen[d] = true
				domains = append(domains, d)
			}
		}
	}

	// Format domains for the Envoy virtual host (CONNECT uses host:port).
	var domainLines []string
	for _, d := range domains {
		domainLines = append(domainLines, fmt.Sprintf("              - \"%s:443\"", d))
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Do not edit directly.
#
# Envoy unified proxy: ingress (TLS reverse proxy) + egress (HTTP CONNECT forward proxy).
# Restart after editing: docker compose restart envoy

static_resources:
  listeners:
  # Ingress: TLS termination + reverse proxy to gateway
  - name: ingress
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 443
    filter_chains:
    - transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          common_tls_context:
            tls_params:
              tls_minimum_protocol_version: TLSv1_2
            tls_certificates:
            - certificate_chain:
                filename: /etc/envoy/certs/server-cert.pem
              private_key:
                filename: /etc/envoy/certs/server-key.pem
            # --- mTLS (Cloudflare Authenticated Origin Pulls) ---
            # To verify client certificates from an edge proxy like Cloudflare:
            # 1. Download the Cloudflare origin pull CA from:
            #    https://developers.cloudflare.com/ssl/origin-configuration/authenticated-origin-pull/
            # 2. Save it as compose/envoy/cloudflare-origin-pull-ca.pem
            # 3. Mount it in compose.yaml:
            #      - ./compose/envoy/cloudflare-origin-pull-ca.pem:/etc/envoy/certs/client-ca.pem:ro
            # 4. Uncomment the following lines:
            #
            # validation_context:
            #   trusted_ca:
            #     filename: /etc/envoy/certs/client-ca.pem
          # require_client_certificate: true
      filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress
          use_remote_address: true
          xff_num_trusted_hops: 0
          upgrade_configs:
          - upgrade_type: websocket
          route_config:
            name: ingress_route
            virtual_hosts:
            - name: gateway
              domains: ["*"]
              routes:
              - match:
                  prefix: "/"
                route:
                  cluster: openclaw_gateway
                  timeout: 0s
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  # Egress: HTTP CONNECT forward proxy with domain whitelist
  - name: egress
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: egress
          http_protocol_options:
            accept_http_10: true
          upgrade_configs:
          - upgrade_type: CONNECT
          route_config:
            name: egress_route
            virtual_hosts:
            - name: allowed
              domains:
%s
              routes:
              - match:
                  connect_matcher: {}
                route:
                  cluster: dynamic_forward_proxy
                  upgrade_configs:
                  - upgrade_type: CONNECT
                    connect_config: {}
            - name: deny_all
              domains: ["*"]
              routes:
              - match:
                  connect_matcher: {}
                direct_response:
                  status: 403
                  body:
                    inline_string: "Forbidden: domain not in egress whitelist"
          http_filters:
          - name: envoy.filters.http.dynamic_forward_proxy
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
              dns_cache_config:
                name: dynamic_forward_proxy_cache
                dns_lookup_family: V4_PREFERRED
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
  - name: openclaw_gateway
    type: STRICT_DNS
    connect_timeout: 2s
    load_assignment:
      cluster_name: openclaw_gateway
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: openclaw-gateway
                port_value: %s

  - name: dynamic_forward_proxy
    lb_policy: CLUSTER_PROVIDED
    cluster_type:
      name: envoy.clusters.dynamic_forward_proxy
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
        dns_cache_config:
          name: dynamic_forward_proxy_cache
          dns_lookup_family: V4_PREFERRED
`, strings.Join(domainLines, "\n"), gatewayPort)
}

func writeEnvoyConfig(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "envoy", "envoy.yaml")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(envoyConfigContent(opts)), 0o644); err != nil {
		return fmt.Errorf("write envoy.yaml %q: %w", path, err)
	}

	return nil
}

func entrypointContent() string {
	return `#!/bin/bash
# Generated by openclaw-docker. Runs as root to set iptables, then drops to node.
#
# Security model: the gateway container runs on an internal-only Docker network
# (no default route to the internet). These iptables rules add defense-in-depth:
# even if Docker networking were misconfigured, only traffic to the Envoy proxy
# is allowed. The node user cannot modify these rules (requires CAP_NET_ADMIN
# which is only available to root).
set -euo pipefail

# Resolve Envoy's IP on the internal network.
ENVOY_IP="$(getent hosts envoy | awk '{print $1}')"
if [ -z "$ENVOY_IP" ]; then
  echo "ERROR: cannot resolve 'envoy' — is the envoy service running?" >&2
  exit 1
fi

# Flush any existing rules.
iptables -F OUTPUT 2>/dev/null || true
iptables -F INPUT 2>/dev/null || true

# Default policy: drop all outbound traffic.
iptables -P OUTPUT DROP

# Allow loopback (localhost).
iptables -A OUTPUT -o lo -j ACCEPT

# Allow DNS to Docker's embedded resolver (needed for service discovery).
iptables -A OUTPUT -d 127.0.0.11/32 -p udp --dport 53 -j ACCEPT

# Allow established/related connections (responses to allowed requests).
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow traffic to Envoy proxy (egress on port 10000, ingress responses).
iptables -A OUTPUT -d "$ENVOY_IP" -j ACCEPT

# Log and drop everything else (optional: helps debug blocked connections).
iptables -A OUTPUT -j LOG --log-prefix "OPENCLAW-BLOCKED: " --log-level warning 2>/dev/null || true

# Drop privileges and exec the CMD as the node user.
exec gosu node "$@"
`
}

func writeEntrypoint(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "openclaw", "entrypoint.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(entrypointContent()), 0o755); err != nil {
		return fmt.Errorf("write entrypoint.sh %q: %w", path, err)
	}

	return nil
}
