package render

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/schmitthub/openclaw-docker/internal/versions"
)

var validDomain = regexp.MustCompile(`^(\*\.)?[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?$`)

type Options struct {
	Meta                 versions.ReleaseMeta
	OutputDir            string
	Cleanup              bool
	DockerAptPackages    string
	OpenClawConfigDir    string
	OpenClawWorkspaceDir string
	OpenClawGatewayPort  string
	OpenClawBridgePort   string
	OpenClawGatewayBind  string
	OpenClawGatewayToken string
	AllowedDomains       string
	ExternalOrigin       string
	ConfirmWrite         func(path string) error
}

func Generate(opts Options) error {
	if opts.OutputDir == "" {
		return fmt.Errorf("output directory is required")
	}

	// Create output root and compose service subdirectories.
	// data/config and data/workspace are runtime state created by setup.sh,
	// not deployment artifacts — generate must not touch them.
	for _, sub := range []string{
		"",
		"compose/openclaw",
		"compose/envoy",
	} {
		dir := filepath.Join(opts.OutputDir, sub)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("create directory %q: %w", dir, err)
		}
	}

	if opts.Cleanup {
		fmt.Fprintf(
			os.Stderr,
			"Defensive warning: cleanup requested for %s\nPrompt: this path would be cleared in cleanup mode, but delete operations are disabled; continuing in additive overwrite-only mode.\n",
			opts.OutputDir,
		)
	}

	dockerfilePath := filepath.Join(opts.OutputDir, "compose", "openclaw", "Dockerfile")
	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(dockerfilePath); err != nil {
			return err
		}
	}
	content := dockerfileFor(opts)
	if err := os.WriteFile(dockerfilePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write Dockerfile %q: %w", dockerfilePath, err)
	}

	if err := writeEntrypoint(opts); err != nil {
		return err
	}

	if err := writeComposeArtifacts(opts); err != nil {
		return err
	}

	if err := writeSetupScript(opts); err != nil {
		return err
	}

	if err := generateTLSCert(opts); err != nil {
		return err
	}

	if err := writeEnvoyConfig(opts); err != nil {
		return err
	}

	if err := writeCLIWrapper(opts); err != nil {
		return err
	}

	return nil
}

func writeComposeArtifacts(opts Options) error {
	composePath := filepath.Join(opts.OutputDir, "compose.yaml")
	envPath := filepath.Join(opts.OutputDir, ".env.openclaw")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(composePath); err != nil {
			return err
		}
	}

	composeContent := composeFileContent(opts)
	if err := os.WriteFile(composePath, []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("write compose file %q: %w", composePath, err)
	}

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(envPath); err != nil {
			return err
		}
	}

	envContent := openClawEnvFileContent(opts)
	if err := os.WriteFile(envPath, []byte(envContent), 0o644); err != nil {
		return fmt.Errorf("write env file %q: %w", envPath, err)
	}

	return nil
}

func writeSetupScript(opts Options) error {
	setupPath := filepath.Join(opts.OutputDir, "setup.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(setupPath); err != nil {
			return err
		}
	}

	content := setupScriptContent(opts)
	if err := os.WriteFile(setupPath, []byte(content), 0o755); err != nil {
		return fmt.Errorf("write setup script %q: %w", setupPath, err)
	}

	return nil
}

func composeFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	lines := []string{
		"# Generated by openclaw-docker. Do not edit directly.",
		"services:",
		"  envoy:",
		"    image: envoyproxy/envoy:v1.33-latest",
		"    sysctls:",
		"      - net.ipv4.ip_unprivileged_port_start=53",
		"    restart: unless-stopped",
		"    ports:",
		"      - \"443:443\"",
		"    volumes:",
		"      - ./compose/envoy/envoy.yaml:/etc/envoy/envoy.yaml:ro",
		"      - ./compose/envoy/server-cert.pem:/etc/envoy/certs/server-cert.pem:ro",
		"      - ./compose/envoy/server-key.pem:/etc/envoy/certs/server-key.pem:ro",
		"    networks:",
		"      openclaw-internal:",
		"        ipv4_address: 172.28.0.2",
		"      openclaw-egress:",
		"",
		"  openclaw-gateway:",
		"    build:",
		"      context: ./compose/openclaw",
		"      dockerfile: Dockerfile",
		"    cap_add:",
		"      - NET_ADMIN",
		"    dns:",
		"      - 172.28.0.2",
		"    environment:",
		"      HOME: /home/node",
		"      TERM: xterm-256color",
		"    env_file:",
		"      - .env.openclaw",
		"    volumes:",
		fmt.Sprintf("      - ./data/config:%s", configDir),
		fmt.Sprintf("      - ./data/workspace:%s", workspaceDir),
		fmt.Sprintf("    command: [\"openclaw\", \"gateway\", \"--bind\", \"%s\", \"--port\", \"%s\"]", gatewayBind, gatewayPort),
		"    init: true",
		"    restart: unless-stopped",
		"    depends_on:",
		"      - envoy",
		"    networks:",
		"      - openclaw-internal",
		"",
		"",
		"networks:",
		"  openclaw-internal:",
		"    internal: true",
		"    ipam:",
		"      config:",
		"        - subnet: 172.28.0.0/24",
		"  openclaw-egress:",
	}

	return strings.Join(lines, "\n") + "\n"
}

func openClawEnvFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Adjust values as needed.
OPENCLAW_CONFIG_DIR=%s
OPENCLAW_WORKSPACE_DIR=%s
OPENCLAW_GATEWAY_PORT=%s
OPENCLAW_BRIDGE_PORT=%s
OPENCLAW_GATEWAY_BIND=%s
OPENCLAW_GATEWAY_TOKEN=%s
OPENCLAW_DOCKER_APT_PACKAGES=%s
`, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind, opts.OpenClawGatewayToken, opts.DockerAptPackages)
}

func dockerfileFor(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`#
# NOTE: THIS DOCKERFILE IS GENERATED VIA "openclaw-docker"
#
# PLEASE DO NOT EDIT IT DIRECTLY.
#

FROM node:22-bookworm

ARG OPENCLAW_DOCKER_APT_PACKAGES="%s"
RUN apt-get update && \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
      iptables iproute2 gosu libsecret-tools \
      $OPENCLAW_DOCKER_APT_PACKAGES && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*

# Install Bun (required for build scripts).
# Binary copied to /usr/local/bin/ so node user can access it at runtime.
# (Symlinking through /root/ fails — root home is mode 0700.)
RUN curl -fsSL https://bun.sh/install | bash && \
    cp /root/.bun/bin/bun /usr/local/bin/bun

# Install pnpm globally (used by OpenClaw for skill/plugin installs at runtime).
# PNPM_HOME sets the global bin directory so pnpm install -g works as node user.
ENV PNPM_HOME=/home/node/.local/share/pnpm
ENV PATH="${PNPM_HOME}:${PATH}"
RUN npm install -g pnpm && \
    mkdir -p "${PNPM_HOME}" && chown -R node:node /home/node/.local

# Install Homebrew (Linuxbrew). Installer refuses to run as root,
# but needs the target directory to exist and be writable.
RUN mkdir -p /home/linuxbrew/.linuxbrew && chown -R node:node /home/linuxbrew
USER node
RUN NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
USER root
ENV PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:${PATH}"

WORKDIR /app
RUN chown node:node /app

ENV OPENCLAW_VERSION=%s
ENV OPENCLAW_CONFIG_DIR=%s
ENV OPENCLAW_WORKSPACE_DIR=%s
ENV OPENCLAW_GATEWAY_PORT=%s
ENV OPENCLAW_BRIDGE_PORT=%s
ENV OPENCLAW_GATEWAY_BIND=%s

# Create config and workspace directories
RUN mkdir -p "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}" && \
    chown -R node:node "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}"

# Install OpenClaw via npm (global, as root → /usr/local).
# NODE_OPTIONS reduces OOM risk on low-memory hosts (exit 137).
RUN SHARP_IGNORE_GLOBAL_LIBVIPS=1 NODE_OPTIONS=--max-old-space-size=2048 \
    npm install -g --no-fund --no-audit "openclaw@${OPENCLAW_VERSION}"

# CLI symlink for consistent access across users
RUN ln -sf "$(npm root -g)/openclaw/dist/entry.js" /usr/local/bin/openclaw && \
    chmod 755 "$(npm root -g)/openclaw/dist/entry.js"

# Optional: bake Playwright + Chromium into the image for browser automation.
# Build with: docker build --build-arg OPENCLAW_INSTALL_BROWSER=1 ...
# Adds ~300MB but eliminates the 60-90s Playwright install on every container start.
ARG OPENCLAW_INSTALL_BROWSER=""
RUN if [ -n "$OPENCLAW_INSTALL_BROWSER" ]; then \
      apt-get update && \
      DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends xvfb && \
      mkdir -p /home/node/.cache/ms-playwright && \
      PLAYWRIGHT_BROWSERS_PATH=/home/node/.cache/ms-playwright \
      node "$(npm root -g)/openclaw/node_modules/playwright-core/cli.js" install --with-deps chromium && \
      chown -R node:node /home/node/.cache/ms-playwright && \
      apt-get clean && \
      rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*; \
    fi

COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod 755 /usr/local/bin/entrypoint.sh

# Force pnpm for package operations (Bun may fail on ARM/Synology architectures).
ENV OPENCLAW_PREFER_PNPM=1
ENV NODE_ENV=production

ENTRYPOINT ["entrypoint.sh"]
CMD ["openclaw", "gateway", "--allow-unconfigured"]
`, opts.DockerAptPackages, opts.Meta.FullVersion, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind)
}

func setupScriptContent(opts Options) string {
	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	originJSON := `'["https://localhost"]'`
	if opts.ExternalOrigin != "" {
		originJSON = fmt.Sprintf(`'["https://localhost", "%s"]'`, opts.ExternalOrigin)
	}

	return fmt.Sprintf(`#!/usr/bin/env bash
# Generated by openclaw-docker. Adjust as needed.
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$ROOT_DIR/compose.yaml"
ENV_FILE="$ROOT_DIR/.env.openclaw"

# Host-side data directories (bind-mounted into the container).
HOST_CONFIG_DIR="$ROOT_DIR/data/config"
HOST_WORKSPACE_DIR="$ROOT_DIR/data/workspace"

# Derive image/network names from compose project (directory name).
COMPOSE_PROJECT="$(basename "$ROOT_DIR")"
GATEWAY_IMAGE="${COMPOSE_PROJECT}-openclaw-gateway"
NETWORK="${COMPOSE_PROJECT}_openclaw-internal"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing dependency: $1" >&2
    exit 1
  fi
}

SKIP_ONBOARDING=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --skip-onboarding)
      SKIP_ONBOARDING=true
      shift
      ;;
    -h|--help)
      echo "Usage: ./setup.sh [--skip-onboarding]"
      echo ""
      echo "Options:"
      echo "  --skip-onboarding  Skip interactive onboarding and reuse existing gateway config."
      echo "  -h, --help         Show this help message."
      exit 0
      ;;
    *)
      fail "Unknown argument: $1"
      ;;
  esac
done

# Run an openclaw command against the gateway config (pre-start, local ops).
# Uses compose to inherit volumes/env from the gateway service definition.
# --entrypoint skips the iptables entrypoint; --no-deps skips starting envoy.
gw_config() {
  docker compose -f "$COMPOSE_FILE" run --rm --no-deps openclaw-gateway openclaw "$@"
}

# Read gateway token from existing openclaw config if available.
read_config_gateway_token() {
  local config_path="$HOST_CONFIG_DIR/openclaw.json"
  if [[ ! -f "$config_path" ]]; then
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$config_path" <<'PY'
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    token = cfg.get("gateway", {}).get("auth", {}).get("token", "")
    if token.strip():
        print(token.strip())
except Exception:
    pass
PY
    return 0
  fi
  if command -v node >/dev/null 2>&1; then
    node - "$config_path" <<'NODE'
const fs = require("node:fs");
try {
  const cfg = JSON.parse(fs.readFileSync(process.argv[2], "utf8"));
  const token = cfg?.gateway?.auth?.token;
  if (typeof token === "string" && token.trim()) process.stdout.write(token.trim());
} catch {}
NODE
  fi
}

# Idempotent env file upsert (Bash 3.2 compatible).
upsert_env() {
  local file="$1"
  shift
  local -a keys=("$@")
  local tmp
  tmp="$(mktemp)"
  local seen=" "

  if [[ -f "$file" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      local key="${line%%%%=*}"
      local replaced=false
      for k in "${keys[@]}"; do
        if [[ "$key" == "$k" ]]; then
          printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
          seen="$seen$k "
          replaced=true
          break
        fi
      done
      if [[ "$replaced" == false ]]; then
        printf '%%s\n' "$line" >>"$tmp"
      fi
    done <"$file"
  fi

  for k in "${keys[@]}"; do
    if [[ "$seen" != *" $k "* ]]; then
      printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
    fi
  done

  mv "$tmp" "$file"
}

ensure_control_ui_allowed_origins() {
  local allowed_origin_json=%s

  local current
  current="$(
    gw_config config get gateway.controlUi.allowedOrigins 2>/dev/null || true
  )"
  current="${current//$'\r'/}"

  if [[ -n "$current" && "$current" != "null" && "$current" != "[]" ]]; then
    echo "Control UI allowlist already configured; leaving gateway.controlUi.allowedOrigins unchanged."
    return 0
  fi

  gw_config config set gateway.controlUi.allowedOrigins \
    "$allowed_origin_json" --strict-json >/dev/null
  echo "Set gateway.controlUi.allowedOrigins to $allowed_origin_json"
}

require_cmd docker
if ! docker compose version >/dev/null 2>&1; then
  fail "Docker Compose not available (try: docker compose version)"
fi

# Create host-side data directories.
mkdir -p "$HOST_CONFIG_DIR"
mkdir -p "$HOST_WORKSPACE_DIR"
mkdir -p "$HOST_CONFIG_DIR/identity"

export OPENCLAW_GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-%s}"
export OPENCLAW_BRIDGE_PORT="${OPENCLAW_BRIDGE_PORT:-18790}"
export OPENCLAW_GATEWAY_BIND="${OPENCLAW_GATEWAY_BIND:-lan}"

# Update .env file with runtime values (port, bind).
# Token is written after onboard (see below).
upsert_env "$ENV_FILE" \
  OPENCLAW_GATEWAY_PORT \
  OPENCLAW_BRIDGE_PORT \
  OPENCLAW_GATEWAY_BIND

echo "==> Building images"
docker compose -f "$COMPOSE_FILE" build

if [[ "$SKIP_ONBOARDING" == "true" ]]; then
  echo ""
  echo "==> Skipping onboarding (--skip-onboarding)"
  echo "Reusing existing gateway config from $HOST_CONFIG_DIR/openclaw.json if available."
else
  echo ""
  echo "==> Onboarding (interactive)"
  echo "When prompted:"
  echo "  - Gateway bind: lan"
  echo "  - Gateway auth: token"
  echo "  - Tailscale exposure: Off"
  echo "  - Install Gateway daemon: No"
  echo ""
  # Start envoy (dependency) so DNS works, then run onboard.
  docker compose -f "$COMPOSE_FILE" run --rm openclaw-gateway openclaw onboard --no-install-daemon
fi

# Ensure gateway mode is local (required for gateway to start).
# Onboard should set this, but we enforce it as a safety net.
gw_config config set gateway.mode local >/dev/null

# Read the token that onboard set, or generate one if onboard didn't.
echo ""
echo "==> Gateway auth token"
OPENCLAW_GATEWAY_TOKEN="$(read_config_gateway_token || true)"
if [[ -z "$OPENCLAW_GATEWAY_TOKEN" ]]; then
  if command -v openssl >/dev/null 2>&1; then
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
  else
    OPENCLAW_GATEWAY_TOKEN="$(python3 -c 'import secrets; print(secrets.token_hex(32))')"
  fi
  gw_config config set gateway.auth.token "$OPENCLAW_GATEWAY_TOKEN" >/dev/null
  echo "Generated new gateway token."
else
  echo "Using token from onboarding."
fi
export OPENCLAW_GATEWAY_TOKEN

# Ensure auth mode is token.
gw_config config set gateway.auth.mode token >/dev/null

# Write token to .env file so it's available on restarts.
upsert_env "$ENV_FILE" OPENCLAW_GATEWAY_TOKEN

echo ""
echo "==> Trusted proxies (Docker network CIDRs)"
gw_config config set gateway.trustedProxies \
  '["172.16.0.0/12", "10.0.0.0/8", "192.168.0.0/16"]' --strict-json >/dev/null
echo "Set gateway.trustedProxies for Docker network forwarding."

echo ""
echo "==> Control UI origin allowlist"
ensure_control_ui_allowed_origins

echo ""
echo "==> Disable mDNS discovery (not useful in Docker)"
gw_config config set discovery.mdns.mode off >/dev/null

echo ""
echo "==> CLI remote config"
# The CLI runs as a standalone docker run container, connecting to the gateway
# through Envoy's TLS ingress (wss://envoy:443). Config and device identity
# persist on the openclaw-cli-config named volume.
"$ROOT_DIR/openclaw" config set gateway.mode remote >/dev/null
"$ROOT_DIR/openclaw" config set gateway.remote.url "wss://envoy:443" >/dev/null
"$ROOT_DIR/openclaw" config set gateway.remote.transport direct >/dev/null
"$ROOT_DIR/openclaw" config set gateway.remote.token "$OPENCLAW_GATEWAY_TOKEN" >/dev/null
"$ROOT_DIR/openclaw" config set discovery.mdns.mode off >/dev/null
echo "CLI configured for remote access via Envoy."

echo ""
echo "==> Starting services"
docker compose -f "$COMPOSE_FILE" up -d

# Wait for gateway to accept connections.
echo "Waiting for gateway..."
for i in $(seq 1 30); do
  if docker compose -f "$COMPOSE_FILE" exec -T openclaw-gateway \
    openclaw devices list >/dev/null 2>&1; then
    break
  fi
  sleep 1
done

echo ""
echo "==> Pair CLI device"
# Trigger pairing — the CLI connects, gets rejected, but its device identity
# is written to the named volume. Then we approve from the gateway.
"$ROOT_DIR/openclaw" devices list >/dev/null 2>&1 || true
sleep 2
docker compose -f "$COMPOSE_FILE" exec -T openclaw-gateway \
  openclaw devices approve --latest 2>&1 || true

echo ""
echo "==> Provider setup (optional)"
echo "WhatsApp (QR):"
echo "  $ROOT_DIR/openclaw channels login"
echo "Telegram (bot token):"
echo "  $ROOT_DIR/openclaw channels add --channel telegram --token <token>"
echo "Discord (bot token):"
echo "  $ROOT_DIR/openclaw channels add --channel discord --token <token>"
echo "Docs: https://docs.openclaw.ai/channels"

echo ""
echo "Gateway running."
echo ""
echo "  Open: https://localhost/?token=$OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Config:    $HOST_CONFIG_DIR"
echo "Workspace: $HOST_WORKSPACE_DIR"
echo "Token:     $OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Commands:"
echo "  docker compose -f $COMPOSE_FILE logs -f openclaw-gateway"
echo "  $ROOT_DIR/openclaw devices list"
echo ""
echo "Envoy config:   $ROOT_DIR/compose/envoy/envoy.yaml"
echo "Gateway config: $HOST_CONFIG_DIR/openclaw.json"
`, originJSON, gatewayPort)
}

func envoyConfigContent(opts Options) (string, error) {
	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	// Build the domain list for the egress whitelist.
	// These domains are always included regardless of --allowed-domains.
	alwaysAllowed := []string{
		// Infrastructure.
		"clawhub.com",
		"registry.npmjs.org",
		// AI providers.
		"api.anthropic.com",
		"api.openai.com",
		"generativelanguage.googleapis.com",
		"openrouter.ai",
		"api.x.ai",
		// Homebrew (Linuxbrew).
		"github.com",
		"*.githubusercontent.com",
		"ghcr.io",
		"formulae.brew.sh",
	}

	// Deduplicate: start with always-allowed, then add user-specified domains.
	seen := make(map[string]bool)
	var domains []string
	for _, d := range alwaysAllowed {
		seen[d] = true
		domains = append(domains, d)
	}
	if opts.AllowedDomains != "" {
		for _, d := range strings.Split(opts.AllowedDomains, ",") {
			d = strings.TrimSpace(d)
			if d == "" || seen[d] {
				continue
			}
			if len(d) > 253 || !validDomain.MatchString(d) {
				return "", fmt.Errorf("invalid domain %q: must be a valid DNS hostname", d)
			}
			seen[d] = true
			domains = append(domains, d)
		}
	}

	// Format domains for Envoy filter_chain_match server_names (TLS SNI match).
	var domainLines []string
	for _, d := range domains {
		domainLines = append(domainLines, fmt.Sprintf("        - \"%s\"", d))
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Do not edit directly.
#
# Envoy unified proxy: ingress (TLS reverse proxy) + egress (transparent TLS proxy).
# Egress uses TLS Inspector + SNI-based domain whitelist. No MITM / TLS termination.
# All outbound TCP from the gateway is DNAT'd here by iptables in entrypoint.sh.
# Restart after editing: docker compose restart envoy

static_resources:
  listeners:
  # Ingress: TLS termination + reverse proxy to gateway
  - name: ingress
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 443
    filter_chains:
    - transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          common_tls_context:
            tls_params:
              tls_minimum_protocol_version: TLSv1_2
            tls_certificates:
            - certificate_chain:
                filename: /etc/envoy/certs/server-cert.pem
              private_key:
                filename: /etc/envoy/certs/server-key.pem
            # --- mTLS (Cloudflare Authenticated Origin Pulls) ---
            # To verify client certificates from an edge proxy like Cloudflare:
            # 1. Download the Cloudflare origin pull CA from:
            #    https://developers.cloudflare.com/ssl/origin-configuration/authenticated-origin-pull/
            # 2. Save it as compose/envoy/cloudflare-origin-pull-ca.pem
            # 3. Mount it in compose.yaml:
            #      - ./compose/envoy/cloudflare-origin-pull-ca.pem:/etc/envoy/certs/client-ca.pem:ro
            # 4. Uncomment the following lines:
            #
            # validation_context:
            #   trusted_ca:
            #     filename: /etc/envoy/certs/client-ca.pem
          # require_client_certificate: true
      filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress
          use_remote_address: true
          xff_num_trusted_hops: 0
          upgrade_configs:
          - upgrade_type: websocket
          route_config:
            name: ingress_route
            virtual_hosts:
            - name: gateway
              domains: ["*"]
              routes:
              - match:
                  prefix: "/"
                route:
                  cluster: openclaw_gateway
                  timeout: 0s
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  # Egress: transparent TLS proxy with SNI-based domain whitelist.
  # All outbound TCP from the gateway is DNAT'd here by iptables.
  # TLS Inspector reads SNI from ClientHello (no TLS termination / MITM).
  # Whitelisted SNI -> forwarded. Everything else -> connection refused.
  - name: egress
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 10000
    listener_filters:
    - name: envoy.filters.listener.tls_inspector
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.filters.listener.tls_inspector.v3.TlsInspector
    filter_chains:
    # Whitelisted TLS domains (matched by SNI from ClientHello).
    - filter_chain_match:
        server_names:
%s
      filters:
      - name: envoy.filters.network.sni_dynamic_forward_proxy
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.sni_dynamic_forward_proxy.v3.FilterConfig
          port_value: 443
          dns_cache_config:
            name: dynamic_forward_proxy_cache
            dns_lookup_family: V4_PREFERRED
      - name: envoy.filters.network.tcp_proxy
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
          stat_prefix: egress_tls_allowed
          cluster: dynamic_forward_proxy_cluster
    # Default deny: non-whitelisted SNI or non-TLS traffic.
    # Connection is immediately reset (deny_cluster has no endpoints).
    - filters:
      - name: envoy.filters.network.tcp_proxy
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
          stat_prefix: egress_denied
          cluster: deny_cluster

  # DNS: forward resolver for containers on the internal network.
  # Docker's embedded DNS cannot forward external queries from internal-only
  # networks. Gateway and CLI services use dns: [172.28.0.2] (Envoy's static IP)
  # so Docker DNS forwards here instead of failing with SERVFAIL.
  # Upstream: Cloudflare 1.1.1.2 / 1.0.0.2 (malware-blocking DNS).
  - name: dns
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 53
        protocol: UDP
    listener_filters:
    - name: envoy.filters.udp.dns_filter
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig
        stat_prefix: dns
        client_config:
          resolver_timeout: 5s
          max_pending_lookups: 256
          typed_dns_resolver_config:
            name: envoy.network.dns_resolver.cares
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig
              resolvers:
              - socket_address:
                  address: "1.1.1.2"
                  port_value: 53
              - socket_address:
                  address: "1.0.0.2"
                  port_value: 53

  clusters:
  - name: openclaw_gateway
    type: STRICT_DNS
    connect_timeout: 2s
    load_assignment:
      cluster_name: openclaw_gateway
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: openclaw-gateway
                port_value: %s

  - name: dynamic_forward_proxy_cluster
    lb_policy: CLUSTER_PROVIDED
    cluster_type:
      name: envoy.clusters.dynamic_forward_proxy
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
        dns_cache_config:
          name: dynamic_forward_proxy_cache
          dns_lookup_family: V4_PREFERRED

  - name: deny_cluster
    type: STATIC
    connect_timeout: 0.25s
    load_assignment:
      cluster_name: deny_cluster
`, strings.Join(domainLines, "\n"), gatewayPort), nil
}

func writeEnvoyConfig(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "envoy", "envoy.yaml")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	content, err := envoyConfigContent(opts)
	if err != nil {
		return fmt.Errorf("generate envoy config: %w", err)
	}

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write envoy.yaml %q: %w", path, err)
	}

	return nil
}

func entrypointContent() string {
	return `#!/bin/bash
# Generated by openclaw-docker. Runs as root to set iptables, then drops to node.
#
# Security model: iptables DNAT transparently redirects outbound TCP destined
# for the outside world to Envoy's transparent proxy listener. Internal subnet
# traffic (Docker service discovery, container-to-container) passes through
# directly. Envoy inspects TLS SNI to enforce the domain whitelist; non-whitelisted
# or non-TLS external traffic is refused. The FILTER table OUTPUT DROP policy
# provides defense-in-depth: only loopback, Docker DNS, the internal subnet,
# and Envoy (via DNAT) are reachable.
# The node user cannot modify these rules (requires CAP_NET_ADMIN, root only).
set -euo pipefail

# Resolve Envoy's IP on the internal network.
ENVOY_IP="$(getent hosts envoy | awk '{print $1}')"
if [ -z "$ENVOY_IP" ]; then
  echo "ERROR: cannot resolve 'envoy' — is the envoy service running?" >&2
  exit 1
fi

# Derive the internal subnet (/24 matches compose IPAM config).
INTERNAL_SUBNET="${ENVOY_IP%.*}.0/24"

# Add a default route via Envoy. The internal network has no gateway (internal: true),
# so the kernel rejects connections to external IPs with "Network is unreachable" before
# iptables can DNAT them. This route makes the routing decision succeed; the NAT table
# then rewrites the destination to Envoy's egress listener.
ip route add default via "$ENVOY_IP" 2>/dev/null || true

# Flush any existing rules (filter + nat tables).
iptables -F OUTPUT 2>/dev/null || true
iptables -F INPUT 2>/dev/null || true
iptables -t nat -F OUTPUT 2>/dev/null || true

# Restore Docker's internal DNS port-remap rules (flushing OUTPUT removes the
# jump to DOCKER_OUTPUT, which DNAT's port 53 to Docker's actual DNS listener).
iptables -t nat -A OUTPUT -j DOCKER_OUTPUT 2>/dev/null || true

# === NAT table: transparent redirect ===
# Skip DNAT for loopback (gateway health checks, local services).
iptables -t nat -A OUTPUT -o lo -j RETURN
# Skip DNAT for internal subnet (container-to-container, Docker service discovery).
iptables -t nat -A OUTPUT -p tcp -d "$INTERNAL_SUBNET" -j RETURN
# Redirect all other outbound TCP to Envoy's transparent proxy listener.
iptables -t nat -A OUTPUT -p tcp -j DNAT --to-destination "$ENVOY_IP":10000

# === FILTER table: defense in depth ===
# Default policy: drop all outbound traffic.
iptables -P OUTPUT DROP

# Allow loopback (localhost).
iptables -A OUTPUT -o lo -j ACCEPT

# Allow DNS to Docker's embedded resolver (needed for service discovery).
iptables -A OUTPUT -d 127.0.0.11/32 -p udp --dport 53 -j ACCEPT

# Allow established/related connections (responses to allowed requests).
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow internal network (container-to-container, service discovery, Envoy).
iptables -A OUTPUT -d "$INTERNAL_SUBNET" -j ACCEPT

# Log and drop everything else (helps debug blocked connections).
iptables -A OUTPUT -j LOG --log-prefix "OPENCLAW-BLOCKED: " --log-level warning 2>/dev/null || true

# Drop privileges and exec the CMD as the node user.
exec gosu node "$@"
`
}

func writeEntrypoint(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "openclaw", "entrypoint.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(entrypointContent()), 0o755); err != nil {
		return fmt.Errorf("write entrypoint.sh %q: %w", path, err)
	}

	return nil
}

func cliWrapperContent() string {
	return `#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_PROJECT="$(basename "$ROOT_DIR")"
GATEWAY_IMAGE="${COMPOSE_PROJECT}-openclaw-gateway"
NETWORK="${COMPOSE_PROJECT}_openclaw-egress"

# Run CLI as a remote client, connecting to the gateway via Envoy TLS ingress.
# Uses its own config directory (separate from the gateway config).
ARGS=(
  docker run --rm
  --network "$NETWORK"
  -v "$ROOT_DIR/data/cli-config:/home/node/.openclaw"
  -v "$ROOT_DIR/compose/envoy/server-cert.pem:/etc/ssl/certs/openclaw-ca.pem:ro"
  -e HOME=/home/node
  -e NODE_EXTRA_CA_CERTS=/etc/ssl/certs/openclaw-ca.pem
  --entrypoint openclaw
)

# Attach terminal if stdin is a TTY.
if [ -t 0 ]; then
  ARGS+=(-it)
fi

exec "${ARGS[@]}" "$GATEWAY_IMAGE" "$@"
`
}

func writeCLIWrapper(opts Options) error {
	path := filepath.Join(opts.OutputDir, "openclaw")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(cliWrapperContent()), 0o755); err != nil {
		return fmt.Errorf("write openclaw wrapper %q: %w", path, err)
	}

	return nil
}
