package render

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/schmitthub/openclaw-docker/internal/versions"
)

type Options struct {
	Meta                 versions.ReleaseMeta
	OutputDir            string
	Cleanup              bool
	DockerAptPackages    string
	OpenClawConfigDir    string
	OpenClawWorkspaceDir string
	OpenClawGatewayPort  string
	OpenClawBridgePort   string
	OpenClawGatewayBind  string
	OpenClawImage        string
	OpenClawGatewayToken string
	OpenClawExtraMounts  string
	OpenClawHomeVolume   string
	SquidAllowedDomains  string
	ConfirmWrite         func(path string) error
}

func Generate(opts Options) error {
	if opts.OutputDir == "" {
		return fmt.Errorf("output directory is required")
	}

	// Create output root and compose service subdirectories.
	for _, sub := range []string{
		"",
		"compose/openclaw",
		"compose/squid",
		"compose/nginx",
	} {
		dir := filepath.Join(opts.OutputDir, sub)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("create directory %q: %w", dir, err)
		}
	}

	if opts.Cleanup {
		fmt.Fprintf(
			os.Stderr,
			"Defensive warning: cleanup requested for %s\nPrompt: this path would be cleared in cleanup mode, but delete operations are disabled; continuing in additive overwrite-only mode.\n",
			opts.OutputDir,
		)
	}

	dockerfilePath := filepath.Join(opts.OutputDir, "compose", "openclaw", "Dockerfile")
	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(dockerfilePath); err != nil {
			return err
		}
	}
	content := dockerfileFor(opts)
	if err := os.WriteFile(dockerfilePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write Dockerfile %q: %w", dockerfilePath, err)
	}

	if err := writeComposeArtifacts(opts); err != nil {
		return err
	}

	if err := writeSetupScript(opts); err != nil {
		return err
	}

	if err := generateCA(opts); err != nil {
		return err
	}

	if err := generateNginxCert(opts); err != nil {
		return err
	}

	if err := writeNginxConf(opts); err != nil {
		return err
	}

	if err := writeSquidDockerfile(opts); err != nil {
		return err
	}

	if err := writeSquidConf(opts); err != nil {
		return err
	}

	if err := writeOpenClawJSON(opts); err != nil {
		return err
	}

	return nil
}

func writeComposeArtifacts(opts Options) error {
	composePath := filepath.Join(opts.OutputDir, "compose.yaml")
	envPath := filepath.Join(opts.OutputDir, ".env.openclaw")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(composePath); err != nil {
			return err
		}
	}

	composeContent := composeFileContent()
	if err := os.WriteFile(composePath, []byte(composeContent), 0o644); err != nil {
		return fmt.Errorf("write compose file %q: %w", composePath, err)
	}

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(envPath); err != nil {
			return err
		}
	}

	envContent := openClawEnvFileContent(opts)
	if err := os.WriteFile(envPath, []byte(envContent), 0o644); err != nil {
		return fmt.Errorf("write env file %q: %w", envPath, err)
	}

	return nil
}

func writeSetupScript(opts Options) error {
	setupPath := filepath.Join(opts.OutputDir, "setup.sh")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(setupPath); err != nil {
			return err
		}
	}

	content := setupScriptContent(opts)
	if err := os.WriteFile(setupPath, []byte(content), 0o755); err != nil {
		return fmt.Errorf("write setup script %q: %w", setupPath, err)
	}

	return nil
}

func composeFileContent() string {
	lines := []string{
		"# Generated by openclaw-docker. Do not edit directly.",
		"services:",
		"  nginx:",
		"    image: nginx:alpine",
		"    restart: unless-stopped",
		"    ports:",
		"      - \"443:443\"",
		"    volumes:",
		"      - ./compose/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro",
		"      - ./compose/nginx/nginx-cert.pem:/etc/nginx/certs/server.pem:ro",
		"      - ./compose/nginx/nginx-key.pem:/etc/nginx/certs/server-key.pem:ro",
		"    depends_on:",
		"      - openclaw-gateway",
		"    networks:",
		"      - openclaw-internal",
		"",
		"  squid:",
		"    build:",
		"      context: ./compose/squid",
		"      dockerfile: Dockerfile.squid",
		"    restart: unless-stopped",
		"    volumes:",
		"      - ./compose/squid/squid.conf:/etc/squid/squid.conf:ro",
		"      - ./compose/squid/ca-cert.pem:/etc/squid/ca-cert.pem:ro",
		"      - ./compose/squid/ca-key.pem:/etc/squid/ca-key.pem:ro",
		"      - squid-log:/var/log/squid",
		"      - squid-cache:/var/spool/squid",
		"    networks:",
		"      - openclaw-internal",
		"      - openclaw-egress",
		"",
		"  openclaw-gateway:",
		"    build:",
		"      context: ./compose/openclaw",
		"      dockerfile: Dockerfile",
		"    env_file:",
		"      - .env.openclaw",
		"    environment:",
		"      OPENCLAW_CONFIG_DIR: ${OPENCLAW_CONFIG_DIR}",
		"      OPENCLAW_WORKSPACE_DIR: ${OPENCLAW_WORKSPACE_DIR}",
		"      OPENCLAW_GATEWAY_PORT: ${OPENCLAW_GATEWAY_PORT}",
		"      OPENCLAW_BRIDGE_PORT: ${OPENCLAW_BRIDGE_PORT}",
		"      OPENCLAW_GATEWAY_BIND: ${OPENCLAW_GATEWAY_BIND}",
		"      OPENCLAW_GATEWAY_TOKEN: ${OPENCLAW_GATEWAY_TOKEN}",
		"      HTTP_PROXY: ${OPENCLAW_HTTP_PROXY}",
		"      HTTPS_PROXY: ${OPENCLAW_HTTPS_PROXY}",
		"      NO_PROXY: ${OPENCLAW_NO_PROXY}",
		"      NODE_EXTRA_CA_CERTS: /etc/ssl/certs/openclaw-ca.pem",
		"    volumes:",
		"      - ${OPENCLAW_CONFIG_DIR}:${OPENCLAW_CONFIG_DIR}",
		"      - ${OPENCLAW_WORKSPACE_DIR}:${OPENCLAW_WORKSPACE_DIR}",
		"      - ./compose/squid/ca-cert.pem:/etc/ssl/certs/openclaw-ca.pem:ro",
		"    depends_on:",
		"      - squid",
		"    networks:",
		"      - openclaw-internal",
		"",
		"networks:",
		"  openclaw-internal:",
		"    internal: true",
		"  openclaw-egress:",
		"",
		"volumes:",
		"  squid-log:",
		"  squid-cache:",
	}

	return strings.Join(lines, "\n") + "\n"
}

func openClawEnvFileContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Adjust values as needed.
OPENCLAW_CONFIG_DIR=%s
OPENCLAW_WORKSPACE_DIR=%s
OPENCLAW_GATEWAY_PORT=%s
OPENCLAW_BRIDGE_PORT=%s
OPENCLAW_GATEWAY_BIND=%s
OPENCLAW_GATEWAY_TOKEN=%s
OPENCLAW_DOCKER_APT_PACKAGES=%s
OPENCLAW_EXTRA_MOUNTS=%s
OPENCLAW_HOME_VOLUME=%s
OPENCLAW_HTTP_PROXY=http://squid:3128
OPENCLAW_HTTPS_PROXY=http://squid:3128
OPENCLAW_NO_PROXY=localhost,127.0.0.1,squid
`, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind, opts.OpenClawGatewayToken, opts.DockerAptPackages, opts.OpenClawExtraMounts, opts.OpenClawHomeVolume)
}

func dockerfileFor(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	bridgePort := opts.OpenClawBridgePort
	if bridgePort == "" {
		bridgePort = "18790"
	}

	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	return fmt.Sprintf(`#
# NOTE: THIS DOCKERFILE IS GENERATED VIA "openclaw-docker"
#
# PLEASE DO NOT EDIT IT DIRECTLY.
#

FROM node:22-bookworm

ARG OPENCLAW_DOCKER_APT_PACKAGES="%s"
RUN if [ -n "$OPENCLAW_DOCKER_APT_PACKAGES" ]; then \
      apt-get update && \
      DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
        $OPENCLAW_DOCKER_APT_PACKAGES && \
      apt-get clean && \
      rm -rf /var/lib/apt/lists/* /var/cache/apt/archives/*; \
    fi

RUN corepack enable

WORKDIR /app
RUN chown node:node /app

ENV OPENCLAW_VERSION=%s
ENV OPENCLAW_CONFIG_DIR=%s
ENV OPENCLAW_WORKSPACE_DIR=%s
ENV OPENCLAW_GATEWAY_PORT=%s
ENV OPENCLAW_BRIDGE_PORT=%s
ENV OPENCLAW_GATEWAY_BIND=%s

# Create config and workspace directories
RUN mkdir -p "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}" && \
    chown -R node:node "${OPENCLAW_CONFIG_DIR}" "${OPENCLAW_WORKSPACE_DIR}"

USER node

# Install OpenClaw
RUN OPENCLAW_NO_PROMPT=1 OPENCLAW_NO_ONBOARD=1 \
  curl -fsSL "https://openclaw.ai/install.sh" | \
  bash -s -- --version "${OPENCLAW_VERSION}"

ENV NODE_ENV=production

# Start gateway server with default config.
# For container platforms requiring external health checks:
#   1. Set OPENCLAW_GATEWAY_TOKEN or OPENCLAW_GATEWAY_PASSWORD env var
#   2. Override CMD to include: --bind lan
CMD ["node", "openclaw.mjs", "gateway", "--allow-unconfigured"]
`, opts.DockerAptPackages, opts.Meta.FullVersion, configDir, workspaceDir, gatewayPort, bridgePort, gatewayBind)
}

func setupScriptContent(opts Options) string {
	configDir := opts.OpenClawConfigDir
	if configDir == "" {
		configDir = "/home/node/.openclaw"
	}

	workspaceDir := opts.OpenClawWorkspaceDir
	if workspaceDir == "" {
		workspaceDir = "/home/node/.openclaw/workspace"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	return fmt.Sprintf(`#!/usr/bin/env bash
# Generated by openclaw-docker. Adjust as needed.
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$ROOT_DIR/compose.yaml"
ENV_FILE="$ROOT_DIR/.env.openclaw"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing dependency: $1" >&2
    exit 1
  fi
}

# Read gateway token from existing openclaw config if available.
read_config_gateway_token() {
  local config_path="%s/openclaw.json"
  if [[ ! -f "$config_path" ]]; then
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$config_path" <<'PY'
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    token = cfg.get("gateway", {}).get("auth", {}).get("token", "")
    if token.strip():
        print(token.strip())
except Exception:
    pass
PY
    return 0
  fi
  if command -v node >/dev/null 2>&1; then
    node - "$config_path" <<'NODE'
const fs = require("node:fs");
try {
  const cfg = JSON.parse(fs.readFileSync(process.argv[2], "utf8"));
  const token = cfg?.gateway?.auth?.token;
  if (typeof token === "string" && token.trim()) process.stdout.write(token.trim());
} catch {}
NODE
  fi
}

# Idempotent env file upsert (Bash 3.2 compatible).
upsert_env() {
  local file="$1"
  shift
  local -a keys=("$@")
  local tmp
  tmp="$(mktemp)"
  local seen=" "

  if [[ -f "$file" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      local key="${line%%%%=*}"
      local replaced=false
      for k in "${keys[@]}"; do
        if [[ "$key" == "$k" ]]; then
          printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
          seen="$seen$k "
          replaced=true
          break
        fi
      done
      if [[ "$replaced" == false ]]; then
        printf '%%s\n' "$line" >>"$tmp"
      fi
    done <"$file"
  fi

  for k in "${keys[@]}"; do
    if [[ "$seen" != *" $k "* ]]; then
      printf '%%s=%%s\n' "$k" "${!k-}" >>"$tmp"
    fi
  done

  mv "$tmp" "$file"
}

require_cmd docker
if ! docker compose version >/dev/null 2>&1; then
  fail "Docker Compose not available (try: docker compose version)"
fi

# Config and workspace directories
OPENCLAW_CONFIG_DIR="${OPENCLAW_CONFIG_DIR:-%s}"
OPENCLAW_WORKSPACE_DIR="${OPENCLAW_WORKSPACE_DIR:-%s}"

mkdir -p "$OPENCLAW_CONFIG_DIR"
mkdir -p "$OPENCLAW_WORKSPACE_DIR"
mkdir -p "$OPENCLAW_CONFIG_DIR/identity"

export OPENCLAW_CONFIG_DIR
export OPENCLAW_WORKSPACE_DIR
export OPENCLAW_GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-%s}"
export OPENCLAW_BRIDGE_PORT="${OPENCLAW_BRIDGE_PORT:-18790}"
export OPENCLAW_GATEWAY_BIND="${OPENCLAW_GATEWAY_BIND:-lan}"

# Gateway token: reuse from config, env, or generate new.
if [[ -z "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
  EXISTING_TOKEN="$(read_config_gateway_token || true)"
  if [[ -n "$EXISTING_TOKEN" ]]; then
    OPENCLAW_GATEWAY_TOKEN="$EXISTING_TOKEN"
    echo "Reusing gateway token from $OPENCLAW_CONFIG_DIR/openclaw.json"
  elif command -v openssl >/dev/null 2>&1; then
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
  else
    OPENCLAW_GATEWAY_TOKEN="$(python3 -c 'import secrets; print(secrets.token_hex(32))')"
  fi
fi
export OPENCLAW_GATEWAY_TOKEN

# Seed openclaw.json if not already present in config dir.
OPENCLAW_JSON_SEED="$ROOT_DIR/compose/openclaw/openclaw.json"
OPENCLAW_JSON_TARGET="$OPENCLAW_CONFIG_DIR/openclaw.json"
if [[ -f "$OPENCLAW_JSON_SEED" ]] && [[ ! -f "$OPENCLAW_JSON_TARGET" ]]; then
  sed "s/__GATEWAY_TOKEN__/$OPENCLAW_GATEWAY_TOKEN/g" \
    "$OPENCLAW_JSON_SEED" > "$OPENCLAW_JSON_TARGET"
  echo "Seeded gateway config at $OPENCLAW_JSON_TARGET"
elif [[ -f "$OPENCLAW_JSON_TARGET" ]]; then
  echo "Gateway config already exists at $OPENCLAW_JSON_TARGET; skipping seed."
fi

# Update .env file with current values.
upsert_env "$ENV_FILE" \
  OPENCLAW_CONFIG_DIR \
  OPENCLAW_WORKSPACE_DIR \
  OPENCLAW_GATEWAY_PORT \
  OPENCLAW_BRIDGE_PORT \
  OPENCLAW_GATEWAY_BIND \
  OPENCLAW_GATEWAY_TOKEN

echo "==> Building images"
docker compose -f "$COMPOSE_FILE" build

echo ""
echo "==> Starting services"
docker compose -f "$COMPOSE_FILE" up -d nginx

echo ""
echo "Gateway running."
echo "Dashboard: https://localhost"
echo "Config:    $OPENCLAW_CONFIG_DIR"
echo "Workspace: $OPENCLAW_WORKSPACE_DIR"
echo "Token:     $OPENCLAW_GATEWAY_TOKEN"
echo ""
echo "Commands:"
echo "  docker compose -f $COMPOSE_FILE logs -f openclaw-gateway"
echo ""
echo "Nginx config:           $ROOT_DIR/compose/nginx/nginx.conf"
echo "Squid egress whitelist: $ROOT_DIR/compose/squid/squid.conf"
echo "Gateway config:         $OPENCLAW_CONFIG_DIR/openclaw.json"
`, configDir, configDir, workspaceDir, gatewayPort)
}

func squidDockerfileContent() string {
	return `#
# NOTE: THIS DOCKERFILE IS GENERATED VIA "openclaw-docker"
#
# PLEASE DO NOT EDIT IT DIRECTLY.
#

FROM ubuntu:24.04

RUN apt-get update && \
    apt-get install -y --no-install-recommends squid-openssl && \
    rm -rf /var/lib/apt/lists/*

RUN /usr/lib/squid/security_file_certgen -c -s /var/cache/squid/ssl_db -M 4MB && \
    chown -R proxy:proxy /var/cache/squid/ssl_db

EXPOSE 3128

CMD ["squid", "-N"]
`
}

func writeSquidDockerfile(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "squid", "Dockerfile.squid")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(squidDockerfileContent()), 0o644); err != nil {
		return fmt.Errorf("write Dockerfile.squid %q: %w", path, err)
	}

	return nil
}

func squidConfContent(opts Options) string {
	domains := []string{"openclaw.ai"}

	if opts.SquidAllowedDomains != "" {
		for _, d := range strings.Split(opts.SquidAllowedDomains, ",") {
			d = strings.TrimSpace(d)
			if d != "" {
				domains = append(domains, d)
			}
		}
	}

	var aclLines []string
	for _, d := range domains {
		aclLines = append(aclLines, fmt.Sprintf("acl allowed_domains dstdomain .%s", d))
	}

	lines := []string{
		"# Generated by openclaw-docker. Edit to customize egress whitelist.",
		"#",
		"# Restart squid after editing: docker compose restart squid",
		"",
		"# Allowed destination domains (egress whitelist)",
	}
	lines = append(lines, aclLines...)
	lines = append(lines,
		"",
		"# SSL bump â€” intercept HTTPS via generated certificates",
		"http_port 3128 ssl-bump \\",
		"  cert=/etc/squid/ca-cert.pem \\",
		"  key=/etc/squid/ca-key.pem \\",
		"  generate-host-certificates=on \\",
		"  dynamic_cert_mem_cache_size=4MB",
		"",
		"sslcrtd_program /usr/lib/squid/security_file_certgen -s /var/cache/squid/ssl_db -M 4MB",
		"",
		"# Peek at SNI first, then bump allowed domains, terminate everything else",
		"acl step1 at_step SslBump1",
		"ssl_bump peek step1",
		"ssl_bump bump allowed_domains",
		"ssl_bump terminate all",
		"",
		"# Port ACLs",
		"acl SSL_ports port 443",
		"acl Safe_ports port 80",
		"acl Safe_ports port 443",
		"",
		"# Deny unsafe ports",
		"http_access deny !Safe_ports",
		"http_access deny CONNECT !SSL_ports",
		"",
		"# Allow whitelisted domains, deny everything else",
		"http_access allow allowed_domains",
		"http_access deny all",
		"",
		"# Minimal cache (proxy is for access control, not caching)",
		"cache deny all",
	)

	return strings.Join(lines, "\n") + "\n"
}

func writeSquidConf(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "squid", "squid.conf")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(squidConfContent(opts)), 0o644); err != nil {
		return fmt.Errorf("write squid.conf %q: %w", path, err)
	}

	return nil
}

func openClawJSONContent(opts Options) string {
	gatewayBind := opts.OpenClawGatewayBind
	if gatewayBind == "" {
		gatewayBind = "lan"
	}

	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	return fmt.Sprintf(`{
  "gateway": {
    "mode": "local",
    "bind": "%s",
    "port": %s,
    "auth": {
      "type": "token",
      "token": "__GATEWAY_TOKEN__"
    }
  }
}
`, gatewayBind, gatewayPort)
}

func writeOpenClawJSON(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "openclaw", "openclaw.json")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(openClawJSONContent(opts)), 0o644); err != nil {
		return fmt.Errorf("write openclaw.json %q: %w", path, err)
	}

	return nil
}

func nginxConfContent(opts Options) string {
	gatewayPort := opts.OpenClawGatewayPort
	if gatewayPort == "" {
		gatewayPort = "18789"
	}

	return fmt.Sprintf(`# Generated by openclaw-docker. Adjust as needed.

upstream openclaw_gateway {
    server openclaw-gateway:%s;
}

server {
    listen 443 ssl;
    server_name _;

    ssl_certificate     /etc/nginx/certs/server.pem;
    ssl_certificate_key /etc/nginx/certs/server-key.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;

    # --- mTLS (e.g. Cloudflare Authenticated Origin Pulls) ---
    # To enable mutual TLS, uncomment the lines below and mount your
    # client CA certificate at the path shown. For Cloudflare, download
    # the origin pull CA from the Cloudflare dashboard.
    #
    # ssl_client_certificate /etc/nginx/certs/client-ca.pem;
    # ssl_verify_client on;

    location / {
        proxy_pass http://openclaw_gateway;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }
}
`, gatewayPort)
}

func writeNginxConf(opts Options) error {
	path := filepath.Join(opts.OutputDir, "compose", "nginx", "nginx.conf")

	if opts.ConfirmWrite != nil {
		if err := opts.ConfirmWrite(path); err != nil {
			return err
		}
	}

	if err := os.WriteFile(path, []byte(nginxConfContent(opts)), 0o644); err != nil {
		return fmt.Errorf("write nginx.conf %q: %w", path, err)
	}

	return nil
}
